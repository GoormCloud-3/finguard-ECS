name: ECS Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Î∞∞Ìè¨Ìï† ÌôòÍ≤Ω (dev, main)"
        required: true
        default: "dev"

env:
  AWS_REGION: ap-northeast-2
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_SUBNETS: ${{ secrets.AWS_SUBNETS }}               # "subnet-aaa,subnet-bbb"
  AWS_SECURITY_GROUPS: ${{ secrets.AWS_SECURITY_GROUPS }} # "sg-xxx,sg-yyy"
  CLUSTER_NAME: ecs-cluster
  SERVICES: account-service,transaction-service,user-service,sqs-service,fcm-service

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/ecs-deploy-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubECSDeploySession

      - name: Ensure tools
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq gettext-base  # envsubst Ï†úÍ≥µ Ìå®ÌÇ§ÏßÄ
          echo "::add-mask::${AWS_ACCOUNT_ID}"

      - name: Ensure ECS Cluster Exists
        run: |
          set -Eeuo pipefail
          aws ecs describe-clusters --clusters "$CLUSTER_NAME" --query "clusters[0].status" --output text >/dev/null 2>&1 || \
          aws ecs create-cluster --cluster-name "$CLUSTER_NAME"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Docker Images (paths aligned)
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            case "$svc" in
              account-service)      BUILD_DIR="./account-service" ;;
              transaction-service)  BUILD_DIR="./transaction-service" ;;
              user-service)         BUILD_DIR="./user-service" ;;
              sqs-service)          BUILD_DIR="./sqs-service" ;;
              fcm-service)          BUILD_DIR="./fcm-service" ;;
              *) echo "Unknown service: $svc"; exit 1 ;;
            esac

            # Ensure ECR repo
            aws ecr describe-repositories --repository-names "$svc" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$svc"

            IMAGE_SHA_TAG="${GITHUB_SHA}"
            ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${svc}"

            docker buildx build --platform linux/amd64 \
              -t "${svc}:${IMAGE_SHA_TAG}" -t "${svc}:latest" "${BUILD_DIR}" --load
            docker tag "${svc}:${IMAGE_SHA_TAG}" "${ECR_URI}:${IMAGE_SHA_TAG}"
            docker tag "${svc}:latest"          "${ECR_URI}:latest"
            docker push "${ECR_URI}:${IMAGE_SHA_TAG}"
            docker push "${ECR_URI}:latest"
          done

      - name: Scan Docker Images in ECR (fail on CRITICAL/HIGH)
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            aws ecr start-image-scan --repository-name "$svc" --image-id imageTag=latest || true
            sleep 10
            COUNT=$(aws ecr describe-image-scan-findings \
              --repository-name "$svc" \
              --image-id imageTag=latest \
              --query "length(imageScanFindings.findings[?severity==\`CRITICAL\` || severity==\`HIGH\`])" \
              --output text || echo 0)
            echo "$svc: CRITICAL/HIGH findings = $COUNT"
            if [ "$COUNT" != "None" ] && [ "$COUNT" -gt 0 ]; then
              echo "‚ùå Vulnerabilities found in $svc. Abort."
              exit 1
            fi
          done

      - name: Mirror AWS X-Ray Daemon to Private ECR
        run: |
          set -Eeuo pipefail
          REPO_NAME="xray-daemon"
          IMAGE_TAG="3.x"
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}:${IMAGE_TAG}"
          aws ecr describe-repositories --repository-names "$REPO_NAME" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$REPO_NAME"
          docker pull public.ecr.aws/xray/aws-xray-daemon:${IMAGE_TAG}
          docker tag  public.ecr.aws/xray/aws-xray-daemon:${IMAGE_TAG} "$ECR_URI"
          docker push "$ECR_URI"

      # üî• ÌïµÏã¨: ÏûêÎ¶¨ÌëúÏãúÏûê ‚Üí Ïã§Ï†úÍ∞í Î†åÎçî & Îì±Î°ù
      - name: Render & Register Task Definitions (envsubst)
        run: |
          set -Eeuo pipefail
          IMAGE_TAG="${GITHUB_SHA}"   # Î∞∞Ìè¨ Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ = Ïù¥Î≤à Ïª§Î∞ã
          export AWS_ACCOUNT_ID AWS_REGION IMAGE_TAG

          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            base="${svc%-service}"  # account-service -> account
            SRC="./task-definition/${base}-task-definition.json"
            OUT="./task-definition/__rendered_${base}.json"
            [ -f "$SRC" ] || { echo "Task definition not found: $SRC"; exit 1; }

            # ${AWS_ACCOUNT_ID}, ${AWS_REGION}, ${IMAGE_TAG} ÏπòÌôò
            envsubst '$AWS_ACCOUNT_ID,$AWS_REGION,$IMAGE_TAG' < "$SRC" > "$OUT"

            # Îì±Î°ù
            aws ecs register-task-definition --cli-input-json "file://$OUT"
          done

      - name: Create or Update ECS Services (private subnets only)
        run: |
          set -Eeuo pipefail

          NET_CONFIG=$(jq -n \
            --arg subs "$AWS_SUBNETS" \
            --arg sgs  "$AWS_SECURITY_GROUPS" \
            '{
              awsvpcConfiguration: {
                subnets: ($subs | split("[,\\s]+") | map(select(length>0))),
                securityGroups: ($sgs | split("[,\\s]+") | map(select(length>0))),
                assignPublicIp: "DISABLED"
              }  
            }')
          
          echo "AWS_SUBNETS=$AWS_SUBNETS"
          echo "AWS_SECURITY_GROUPS=$AWS_SECURITY_GROUPS"
          echo "NET_CONFIG:"
          echo "$NET_CONFIG" | jq .

          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            TASK_DEF_NAME="${svc%-service}-task"
            STATUS=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$svc" --query "services[0].status" --output text 2>/dev/null || echo "NONE")
            if [ "$STATUS" = "ACTIVE" ]; then
              LATEST_TD=$(aws ecs describe-task-definition --task-definition "$TASK_DEF_NAME" --query "taskDefinition.taskDefinitionArn" --output text)
              aws ecs update-service \
                --cluster "$CLUSTER_NAME" \
                --service "$svc" \
                --task-definition "$TASK_DEF_NAME" \
                --force-new-deployment
            else
              aws ecs create-service \
                --cluster "$CLUSTER_NAME" \
                --service-name "$svc" \
                --task-definition "$TASK_DEF_NAME" \
                --desired-count 1 \
                --launch-type FARGATE \
                --enable-execute-command \
                --network-configuration "$NET_CONFIG"
            fi
          done

      - name: Configure Auto Scaling
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            aws application-autoscaling register-scalable-target \
              --service-namespace ecs \
              --resource-id service/${CLUSTER_NAME}/${svc} \
              --scalable-dimension ecs:service:DesiredCount \
              --min-capacity 1 \
              --max-capacity 10

            aws application-autoscaling put-scaling-policy \
              --service-namespace ecs \
              --resource-id service/${CLUSTER_NAME}/${svc} \
              --scalable-dimension ecs:service:DesiredCount \
              --policy-name "${svc}-cpu-policy" \
              --policy-type TargetTrackingScaling \
              --target-tracking-scaling-policy-configuration '{
                "TargetValue": 70.0,
                "PredefinedMetricSpecification": {"PredefinedMetricType": "ECSServiceAverageCPUUtilization"},
                "ScaleInCooldown": 60,
                "ScaleOutCooldown": 60
              }'
          done
