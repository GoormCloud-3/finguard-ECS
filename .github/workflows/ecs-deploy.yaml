name: ECS Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "배포할 환경 (dev, main)"
        required: true
        default: "dev"

env:
  AWS_REGION: ap-northeast-2
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_SUBNETS: ${{ secrets.AWS_SUBNETS }}               # "subnet-aaa,subnet-bbb"
  AWS_SECURITY_GROUPS: ${{ secrets.AWS_SECURITY_GROUPS }} # "sg-xxx,sg-yyy"
  CLUSTER_NAME: ecs-cluster
  SERVICES: account-service,transaction-service,user-service,sqs-service,fcm-service
  ADOT_REPO: adot-collector
  TG_ACCOUNT_ARN: ${{ secrets.TG_ACCOUNT_ARN }}
  TG_USER_ARN: ${{ secrets.TG_USER_ARN }}
  TG_TRANSACTION_ARN: ${{ secrets.TG_TRANSACTION_ARN }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/ecs-deploy-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubECSDeploySession

      - name: Ensure tools
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq gettext-base
          echo "::add-mask::${AWS_ACCOUNT_ID}"

      - name: Ensure ECS Cluster Exists (robust)
        run: |
          set -Eeuo pipefail
          export AWS_DEFAULT_REGION="${AWS_REGION}"
          STATUS=$(aws ecs describe-clusters --clusters "$CLUSTER_NAME" --query 'clusters[0].status' --output text 2>/dev/null || echo "MISSING")
          if [ "$STATUS" = "MISSING" ] || [ "$STATUS" = "INACTIVE" ] || [ "$STATUS" = "None" ] || [ "$STATUS" = "null" ]; then
            aws ecs create-cluster --cluster-name "$CLUSTER_NAME" >/dev/null
          fi
          for i in {1..30}; do
            STATUS=$(aws ecs describe-clusters --clusters "$CLUSTER_NAME" --query 'clusters[0].status' --output text 2>/dev/null || echo "MISSING")
            [ "$STATUS" = "ACTIVE" ] && break
            sleep 5
          done
          [ "$STATUS" = "ACTIVE" ] || { echo "❌ ECS cluster not ACTIVE"; exit 1; }

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # 🔥 ADOT Collector 전용 이미지 빌드/푸시 (adotCollectorConfig 폴더)
      - name: Build & Push ADOT Collector Image
        run: |
          set -Eeuo pipefail
          REPO="${ADOT_REPO}"
          aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$REPO"
          ADOT_IMAGE_TAG="${GITHUB_SHA}"
          export ADOT_IMAGE_TAG
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO}"
          docker buildx build --platform linux/amd64 \
            -t "${REPO}:${ADOT_IMAGE_TAG}" -t "${REPO}:latest" "./adotCollectorConfig" --load
          docker tag "${REPO}:${ADOT_IMAGE_TAG}" "${ECR_URI}:${ADOT_IMAGE_TAG}"
          docker tag "${REPO}:latest"          "${ECR_URI}:latest"
          docker push "${ECR_URI}:${ADOT_IMAGE_TAG}"
          docker push "${ECR_URI}:latest"
          echo "ADOT_IMAGE_TAG=${ADOT_IMAGE_TAG}" >> $GITHUB_ENV

      - name: Build & Push Service Images
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            case "$svc" in
              account-service)      BUILD_DIR="./account-service" ;;
              transaction-service)  BUILD_DIR="./transaction-service" ;;
              user-service)         BUILD_DIR="./user-service" ;;
              sqs-service)          BUILD_DIR="./sqs-service" ;;
              fcm-service)          BUILD_DIR="./fcm-service" ;;
              *) echo "Unknown service: $svc"; exit 1 ;;
            esac
            aws ecr describe-repositories --repository-names "$svc" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$svc"
            IMAGE_SHA_TAG="${GITHUB_SHA}"
            ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${svc}"
            docker buildx build --platform linux/amd64 \
              -t "${svc}:${IMAGE_SHA_TAG}" -t "${svc}:latest" "${BUILD_DIR}" --load
            docker tag "${svc}:${IMAGE_SHA_TAG}" "${ECR_URI}:${IMAGE_SHA_TAG}"
            docker tag "${svc}:latest"          "${ECR_URI}:latest"
            docker push "${ECR_URI}:${IMAGE_SHA_TAG}"
            docker push "${ECR_URI}:latest"
          done

      - name: Scan Docker Images in ECR (fail on CRITICAL/HIGH)
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra services <<< "$SERVICES"
          # ADOT 이미지는 공개 베이스이지만, 원한다면 함께 스캔
          services+=("${ADOT_REPO}")
          for svc in "${services[@]}"; do
            aws ecr start-image-scan --repository-name "$svc" --image-id imageTag=latest || true
            sleep 10
            COUNT=$(aws ecr describe-image-scan-findings \
              --repository-name "$svc" \
              --image-id imageTag=latest \
              --query "length(imageScanFindings.findings[?severity==\`CRITICAL\` || severity==\`HIGH\`])" \
              --output text || echo 0)
            echo "$svc: CRITICAL/HIGH findings = $COUNT"
            if [ "$COUNT" != "None" ] && [ "$COUNT" -gt 0 ]; then
              echo "❌ Vulnerabilities found in $svc. Abort."
              exit 1
            fi
          done

      # ✅ CloudWatch 로그그룹 사전 생성 (존재 시 무시)
      - name: Ensure CloudWatch Log Groups
        run: |
          set -Eeuo pipefail
          create_lg () {
            local name="$1"
            aws logs describe-log-groups --log-group-name-prefix "$name" --query 'logGroups[?logGroupName==`'"$name"'`]' --output text | grep -q "$name" || \
            aws logs create-log-group --log-group-name "$name"
          }
          # 서비스별
          create_lg "/ecs/account-service"
          create_lg "/ecs/transaction-service"
          create_lg "/ecs/user-service"
          create_lg "/ecs/sqs-service"
          create_lg "/ecs/fcm-service"
          # ADOT
          create_lg "/ecs/adot-collector"

      # 🔥 자리표시자 → 실제값 렌더 & 등록 (ADOT_IMAGE_TAG 포함)
      - name: Render & Register Task Definitions
        run: |
          set -Eeuo pipefail
          IMAGE_TAG="${GITHUB_SHA}"
          export AWS_ACCOUNT_ID AWS_REGION IMAGE_TAG ADOT_IMAGE_TAG
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            base="${svc%-service}"  # account-service -> account
            SRC="./task-definition/${base}-task-definition.json"
            OUT="./task-definition/__rendered_${base}.json"
            [ -f "$SRC" ] || { echo "Task definition not found: $SRC"; exit 1; }
            # ${AWS_ACCOUNT_ID}, ${AWS_REGION}, ${IMAGE_TAG}, ${ADOT_IMAGE_TAG} 치환
            envsubst '$AWS_ACCOUNT_ID,$AWS_REGION,$IMAGE_TAG,$ADOT_IMAGE_TAG' < "$SRC" > "$OUT"
            # 유효성(간단) 검사
            jq . "$OUT" >/dev/null
            aws ecs register-task-definition --cli-input-json "file://$OUT"
          done

      - name: Create or Update ECS Services (private subnets only + ALB for web svcs)
        run: |
          set -Eeuo pipefail

          # ── VPC 네트워크 설정(JSON) ─────────────────────────
          IFS=',' read -ra SUBNET_ARRAY <<< "$AWS_SUBNETS"
          IFS=',' read -ra SG_ARRAY <<< "$AWS_SECURITY_GROUPS"

          NET_CONFIG=$(jq -n \
            --argjson subnets "$(printf '%s\n' "${SUBNET_ARRAY[@]}" | jq -R . | jq -s .)" \
            --argjson sgs     "$(printf '%s\n' "${SG_ARRAY[@]}"   | jq -R . | jq -s .)" \
            '{awsvpcConfiguration: {subnets: $subnets, securityGroups: $sgs, assignPublicIp: "DISABLED"}}')

          # ── 서비스 루프 ─────────────────────────────────────
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            TASK_DEF_NAME="${svc%-service}-task"
            CONTAINER_NAME="$svc"     # task def의 containerDefinitions[].name 과 동일해야 함
            CONTAINER_PORT=8000       # FastAPI uvicorn이 8000 노출

            # 기본: ALB 안 붙임
            TG_ARN=""
            case "$svc" in
              account-service)     TG_ARN="${TG_ACCOUNT_ARN}" ;;
              user-service)        TG_ARN="${TG_USER_ARN}" ;;
              transaction-service) TG_ARN="${TG_TRANSACTION_ARN}" ;;
              *)                   TG_ARN="" ;;   # 나머지(sqs-service, fcm-service)는 ALB 미연결
            esac

            STATUS=$(aws ecs describe-services \
              --cluster "$CLUSTER_NAME" --services "$svc" \
              --query "services[0].status" --output text 2>/dev/null || echo "NONE")

            if [ "$STATUS" = "ACTIVE" ]; then
              # ── 업데이트 ────────────────────────────────────
              if [ -n "$TG_ARN" ]; then
                aws ecs update-service \
                  --cluster "$CLUSTER_NAME" \
                  --service "$svc" \
                  --task-definition "$TASK_DEF_NAME" \
                  --load-balancers targetGroupArn="$TG_ARN",containerName="$CONTAINER_NAME",containerPort=$CONTAINER_PORT \
                  --health-check-grace-period-seconds 60 \
                  --force-new-deployment
              else
                aws ecs update-service \
                  --cluster "$CLUSTER_NAME" \
                  --service "$svc" \
                  --task-definition "$TASK_DEF_NAME" \
                  --force-new-deployment
              fi
            else
              # ── 생성 ───────────────────────────────────────
              if [ -n "$TG_ARN" ]; then
                aws ecs create-service \
                  --cluster "$CLUSTER_NAME" \
                  --service-name "$svc" \
                  --task-definition "$TASK_DEF_NAME" \
                  --desired-count 1 \
                  --launch-type FARGATE \
                  --enable-execute-command \
                  --network-configuration "$NET_CONFIG" \
                  --load-balancers targetGroupArn="$TG_ARN",containerName="$CONTAINER_NAME",containerPort=$CONTAINER_PORT \
                  --health-check-grace-period-seconds 60
              else
                aws ecs create-service \
                  --cluster "$CLUSTER_NAME" \
                  --service-name "$svc" \
                  --task-definition "$TASK_DEF_NAME" \
                  --desired-count 1 \
                  --launch-type FARGATE \
                  --enable-execute-command \
                  --network-configuration "$NET_CONFIG"
              fi
            fi
          done


      - name: Configure Auto Scaling
        run: |
          set -Eeuo pipefail
          IFS=',' read -ra services <<< "$SERVICES"
          for svc in "${services[@]}"; do
            aws application-autoscaling register-scalable-target \
              --service-namespace ecs \
              --resource-id service/${CLUSTER_NAME}/${svc} \
              --scalable-dimension ecs:service:DesiredCount \
              --min-capacity 1 \
              --max-capacity 10

            aws application-autoscaling put-scaling-policy \
              --service-namespace ecs \
              --resource-id service/${CLUSTER_NAME}/${svc} \
              --scalable-dimension ecs:service:DesiredCount \
              --policy-name "${svc}-cpu-policy" \
              --policy-type TargetTrackingScaling \
              --target-tracking-scaling-policy-configuration '{
                "TargetValue": 70.0,
                "PredefinedMetricSpecification": {"PredefinedMetricType": "ECSServiceAverageCPUUtilization"},
                "ScaleInCooldown": 60,
                "ScaleOutCooldown": 60
              }'
          done
